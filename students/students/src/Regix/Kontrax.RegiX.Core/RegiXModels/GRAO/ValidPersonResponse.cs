//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by xsd, Version=4.8.3928.0.
// 
namespace Kontrax.Regix.Core.RegixModels.GRAO {
    using System;
    using System.Globalization;
    using System.Xml.Serialization;

    
    /// <remarks/>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3928.0")]
    [System.SerializableAttribute()]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Xml.Serialization.XmlTypeAttribute(Namespace="http://egov.bg/RegiX/GRAO/NBD/ValidPersonResponse")]
    [System.Xml.Serialization.XmlRootAttribute("ValidPersonResponse", Namespace="http://egov.bg/RegiX/GRAO/NBD/ValidPersonResponse", IsNullable=false)]
    public partial class ValidPersonResponse {
        
        private string firstNameField;
        
        private string surNameField;
        
        private string familyNameField;
        
        private System.DateTime birthDateField;
        
        private bool birthDateFieldSpecified;
        
        private System.DateTime deathDateField;
        
        private bool deathDateFieldSpecified;
        
        /// <remarks/>
        public string FirstName {
            get {
                return ToTitleCaseCustom(this.firstNameField);
            }
            set {
                this.firstNameField = value;
            }
        }
        
        /// <remarks/>
        public string SurName {
            get {
                return ToTitleCaseCustom(this.surNameField);
            }
            set {
                this.surNameField = value;
            }
        }
        
        /// <remarks/>
        public string FamilyName {
            get {
                return ToTitleCaseCustom(this.familyNameField);
            }
            set {
                this.familyNameField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="date")]
        public System.DateTime BirthDate {
            get {
                return this.birthDateField;
            }
            set {
                this.birthDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool BirthDateSpecified {
            get {
                return this.birthDateFieldSpecified;
            }
            set {
                this.birthDateFieldSpecified = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlElementAttribute(DataType="date")]
        public System.DateTime DeathDate {
            get {
                return this.deathDateField;
            }
            set {
                this.deathDateField = value;
            }
        }
        
        /// <remarks/>
        [System.Xml.Serialization.XmlIgnoreAttribute()]
        public bool DeathDateSpecified {
            get {
                return this.deathDateFieldSpecified;
            }
            set {
                this.deathDateFieldSpecified = value;
            }
        }


        string ToTitleCaseCustom(string input)
        {
            if (string.IsNullOrWhiteSpace(input))
                return input;

            var culture = new CultureInfo("bg-BG");

            // Всичко в малки букви
            string lower = input.ToLower(culture);

            // Разделяме по интервал и тире, но пазим разделителите
            char[] separators = { ' ', '-', '–' };
            string[] parts = lower.Split(separators, StringSplitOptions.None);

            string result = lower;
            foreach (string part in parts)
            {
                if (!string.IsNullOrEmpty(part))
                {
                    string fixedPart = char.ToUpper(part[0], culture) + part.Substring(1);
                    result = ReplaceFirst(result, part, fixedPart);
                }
            }

            return result;
        }

        string ReplaceFirst(string text, string search, string replace)
        {
            int pos = text.IndexOf(search, StringComparison.Ordinal);
            if (pos < 0) return text;
            return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);
        }
    }
}
